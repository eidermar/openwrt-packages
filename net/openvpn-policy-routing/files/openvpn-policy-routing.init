#!/bin/sh /etc/rc.common
PKG_VERSION=

export START=94
export USE_PROCD=1

readonly _ok_='\033[0;32m\xe2\x9c\x93\033[0m'
readonly _fail_='\033[0;31m\xe2\x9c\x97\033[0m'
readonly __ok__='\033[0;32m[\xe2\x9c\x93]\033[0m'
readonly __fail__='\033[0;31m[\xe2\x9c\x97]\033[0m'
readonly __pass__='\033[0;33m[-]\033[0m'
readonly _error_='\033[0;31mERROR\033[0m'
# readonly readmeURL="https://github.com/openwrt/packages/tree/master/net/openvpn-policy-routing/files/README.md"
readonly readmeURL="https://github.com/stangri/openwrt-packages/blob/openvpn-policy-routing/net/openvpn-policy-routing/files/README.md"

export EXTRA_COMMANDS="support"
export EXTRA_HELP="	support	Generates output required to troubleshoot routing issues
		Use '-d' option for more detailed output
		Use '-p' option to automatically upload data to paste.ee
		List domain names after options to include their lookup in report"

export verbosity=2 strict=0 TID_WAN='200' MARK_WAN='0x010000' FW_MASK='0xff0000'
export wan_if4 wan_if6

ok() { case $verbosity in 1) output "$_ok_";; 2) output "$__ok__\n";; esac; }
okn() { case $verbosity in 1) output "$_ok_\n";; 2) output "$__ok__\n";; esac; }
fail() { s=1; case $verbosity in 1) output "$_fail_";; 2) output "$__fail__\n";; esac; }
failn() { case $verbosity in 1) output "$_fail_\n";; 2) output "$__fail__\n";; esac; }
output() { [[ $# -ne 1 ]] && { [[ ! $((verbosity & $1)) -gt 0 ]] && return 0 || shift; }; local msg; msg=$(echo -n "${1/$p_name /service }" | sed 's|\\033\[[0-9]\?;\?[0-9]\?[0-9]\?m||g'); [[ -t 1 ]] && echo -e -n "$1"; [[ $(echo -e -n "$msg" | wc -l) -gt 0 ]] && logger -t "${PKG_NAME:-service} [$$]" "$(echo -e -n ${logmsg}${msg})" && logmsg='' || logmsg=${logmsg}${msg}; }
pad_output() { local l v pad text dots width=77; [ "$1" == "-d" ] && dots='...' && shift; [[ $# -ne 1 ]] && v=$1 && shift; [[ $width -lt ${#dots} ]] && l=$width || l=$((width - ${#dots})); pad=$(printf '%*s' $width ""); text="${1:0:$l}${dots}"; output $v "$(printf "%s " "${text}${pad:${#text}}")"; }
PKG_NAME="${PKG_NAME:-openvpn-policy-routing}"; p_name="${PKG_NAME} ${PKG_VERSION}"

is_enabled() {
		local c=1 enabled
		config_load $PKG_NAME
		config_get_bool enabled 'config' 'enabled' 1
		config_get_bool strict  'config' 'strict_enforcement' 0
		config_get verbosity    'config' 'verbosity' '2'
		config_get TID_WAN      'config' 'wan_table_number' '200'
		config_get MARK_WAN     'config' 'wan_fw_mark' '0x010000'
		config_get FW_MASK      'config' 'fw_mask' '0xff0000'

		[[ $enabled -gt 0 ]] || { output "$_error_: $p_name is not enabled.\n"; return 1; }
		source /lib/functions/network.sh
		while : ; do
			network_find_wan wan_if4; network_find_wan6 wan_if6;
			[ -n "$wan_if4" ] && network_get_gateway wan_gw4 "$wan_if4"
			[ -n "$wan_if6" ] && network_get_gateway6 wan_gw6 "$wan_if6"
			wan_gw="${wan_gw4:-$wan_gw6}"
			[[ $c -ge 25 ]] || [ -n "$wan_gw" ] && break
			output "$p_name waiting for wan gateway...\n"; sleep 2; network_flush_cache; let "c+=1";
		done
		[ -n "$wan_gw" ] && return 0 || { output "$_error_: $p_name failed to discover WAN gateway.\n"; return 1; }
}

input() { local data; while read data; do echo "$data" | tee -a /var/openvpn-policy-routing-support; done; }

support() {
	local dist vers out id s param wan_if4 wan_if6 wan_gw4 wan_gw6 status set_d='' set_p='' t_count i=0
	source /lib/functions/network.sh; source /usr/share/libubox/jshn.sh;
	json_load "$(ubus call system board)"; json_select release; json_get_var dist distribution; json_get_var vers version
	network_find_wan wan_if4; network_find_wan6 wan_if6;
	[ -n "$wan_if4" ] && network_get_gateway wan_gw4 "$wan_if4"
	[ -n "$wan_if6" ] && network_get_gateway6 wan_gw6 "$wan_if6"
	while [ "${1:0:1}" == "-" ]; do param="${1//-/}"; eval set_$param="1"; shift; done
	[ -e /var/openvpn-policy-routing-support ] && rm -f /var/openvpn-policy-routing-support
	status="$p_name running on $dist $vers."
	[ -n "$wan_if4" ] && status="$status WAN (IPv4): $wan_if4/${wan_gw4:-0.0.0.0}."
	[ -n "$wan_if6" ] && status="$status WAN (IPv6): $wan_if6/${wan_gw6:-::/0}."
	{
		echo "$status"
		echo "============================================================"
			dnsmasq --version | sed '/^$/,$d'
		[ -n "$1" ] && {
			echo "============================================================"
				echo "Resolving domains"
				while [ -n "$1" ]; do echo "$1: $(resolveip $1 | tr '\n' ' ')"; shift; done; }
		echo "============================================================"
			echo "Routes/IP Rules"
			t_count=$(ip rule list | grep -c 'fwmark') || t_count=0
			[ -z "$set_d" ] && route | grep '^default' || route
			[ -z "$set_d" ] && ip rule list | grep 'fwmark' || ip rule list
			while [ $i -lt $t_count ]; do echo "table $((200 + $i)): $(ip route show table $((200 + $i)))"; let i++; done
		echo "============================================================"
			echo "IP Tables"
			[ -z "$set_d" ] && iptables -L -t mangle | grep '^OPR_CHAIN' || iptables -L -t mangle
			iptables -v -t mangle -S OPR_CHAIN
		echo "============================================================"
			echo "IPv6 Tables"
			[ -z "$set_d" ] && ip6tables -L -t mangle | grep '^OPR_CHAIN' || ip6tables -L -t mangle
			ip6tables -v -t mangle -S OPR_CHAIN
		(f_ipset "dnsmasq" "ipset" || f_ipset "internal" "ipset") && {
		echo "============================================================"
			echo "Domain-based routing settings"
			f_ipset "dnsmasq" print dnsmasq.ipset;
			f_ipset "internal" print openvpn-policy-routing.domain-policy; }
		echo "============================================================"
			echo "Current ipsets"
			ipset save
		echo "============================================================"
	} | input
	if [ -n "$set_p" ]; then
		echo -e -n "Pasting to paste.ee... "
		if [ -x /usr/bin/curl ] && [ -e /usr/lib/libcrypto.so* ] && [ -e /usr/lib/libssl.so* ] && [ -e /etc/ssl/certs/ca-certificates.crt ]; then
			json_init; json_add_string "description" "openvpn-policy-routing-support"
			json_add_array "sections"; json_add_object '0'
			json_add_string "name" "$(uci -q get system.@system[0].hostname)"
			json_add_string "contents" "$(cat /var/openvpn-policy-routing-support)"
			json_close_object; json_close_array; payload=$(json_dump)
			out=$(curl -s -k "https://api.paste.ee/v1/pastes" -X "POST" -H "Content-Type: application/json" -H "X-Auth-Token:uVOJt6pNqjcEWu7qiuUuuxWQafpHhwMvNEBviRV2B" -d "$payload")
			json_load "$out"; json_get_var id id; json_get_var s success
			[ "$s" == "1" ] && echo -e "https://paste.ee/p/$id $__ok__" || echo -e "$__fail__"
			[ -e /var/openvpn-policy-routing-support ] && rm -f /var/openvpn-policy-routing-support
		else
			echo -e "$__fail__"
			echo -e "$_error_: curl, libopenssl or ca-bundle were not found!\nRun 'opkg update; opkg install curl libopenssl ca-bundle' to install them."
			echo -e "Your support details have been logged to '/var/openvpn-policy-routing-support'. $__ok__"
		fi
	fi
}

add_domain_to_ipset() {
	local ip list msg
	[ -n "$1" ] && [ -n "$2" ] || return 1
	ipset -q list "$1" >/dev/null 2>&1 || { d_status="$d_status ipset $1 does not exist"; return 1; }
	if [ "$3" == "1" ]; then
		if [ "${1/route6}" != "$1" ]; then
			[ -x /usr/bin/dig ] && list=$(dig -6 +short "$2" | sed '/\.$/d') || list=$(resolveip -6 "$2" 2>/dev/null)
		else
			[ -x /usr/bin/dig ] && list=$(dig -4 +short "$2" | sed '/\.$/d') || list=$(resolveip -4 "$2" 2>/dev/null)
		fi
		IFS=$' \t\n'; for ip in ${list}; do ipset -q -exist add "$1" "$ip" || { d_status="$d_status failed to add $2/$ip to ipset $1"; return 1; }; done
	else
		ipset -q -exist add "$1" "$2" || { d_status="$d_status failed to add $2 to ipset $1"; return 1; }
	fi
}

process_ipset() {
	local s=1 port ipset resolve i line ipsetname domain
	config_get      port    "$1" port
	config_get      ipset   "$1" ipset
	config_get_bool resolve "$1" resolve
	case $2 in
		active) [ "$port" == "0" ] || fips_status=0;; 														# check if any dnsmasq config is active
		ipset)  [ -n "$ipset" ] && fips_status=0;;																# check if dnsmasq or internal ipsets exist
		output) 																																	# display check-mark per each ipset line
			for i in ${ipset}; do output 3 "$_ok_"; counter=$((counter + 1)); done;
			output 3 '\n'; fips_status=0;;
		print)  for i in ${ipset}; do echo "${3/./.$1.}: ${i}"; done;; 						# print existing ipsets, used in support function
		process)																																	# add internal ipset domains to ipset
			for line in ${ipset}; do
				s=0; ipsetname=${line##*/}; line=${line%/*}; line=${line/\/}; 				# get the ipset name, strip line of ipset ipset name and leading slash
				IFS='/'; for domain in ${line}; do add_domain_to_ipset "$ipsetname" "$domain" "$resolve" || s=1; done;
				[[ $s -eq 0 ]] && output 3 "$_ok_" || output 3 "$_fail_"
				counter=$((counter + 1));
			done
			output 3 '\n'
			;;
	esac
}

f_ipset() {
	local fips_status=1 param="$1"
	counter=0; shift;
	case $param in
		dnsmasq)  config_load dhcp; config_foreach process_ipset dnsmasq "$@";;
		internal) config_load openvpn-policy-routing; config_foreach process_ipset domain-policy "$@";;
	esac
	return $fips_status;
}

ipt() {
    local d; d=$(echo "$*" | sed s/-A/-D/g);
    [ "$d" != "$*" ] && { iptables $d >/dev/null 2>&1; ip6tables $d >/dev/null 2>&1; }
    d=$(echo "$*" | sed s/-I/-D/g)
    [ "$d" != "$*" ] && { iptables $d >/dev/null 2>&1; ip6tables $d >/dev/null 2>&1; }
		d=$(echo "$*" | sed s/-N/-F/g)
    [ "$d" != "$*" ] && { iptables $d >/dev/null 2>&1; ip6tables $d >/dev/null 2>&1; }
		d=$(echo "$*" | sed s/-N/-X/g)
    [ "$d" != "$*" ] && { iptables $d >/dev/null 2>&1; ip6tables $d >/dev/null 2>&1; }
		d="$*"
		ip6tables $d >/dev/null 2>&1 # || output "\n$_error_: ip6tables $d\n"
		iptables $d >/dev/null 2>&1 # || output "\n$_error_: iptables $d\n"
		return 0
}

ipt4() {
    local d; d=$(echo "$*" | sed s/-A/-D/g);
    [ "$d" != "$*" ] && iptables $d >/dev/null 2>&1
    d=$(echo "$*" | sed s/-I/-D/g)
    [ "$d" != "$*" ] && iptables $d >/dev/null 2>&1
		d=$(echo "$*" | sed s/-N/-F/g)
    [ "$d" != "$*" ] && iptables $d >/dev/null 2>&1
		d=$(echo "$*" | sed s/-N/-X/g)
    [ "$d" != "$*" ] && iptables $d >/dev/null 2>&1
		d="$*"
		iptables $d >/dev/null 2>&1 || output "\n$_error_: iptables $d\n"
}

ipt6() {
    local d; d=$(echo "$*" | sed s/-A/-D/g);
    [ "$d" != "$*" ] && ip6tables $d >/dev/null 2>&1
    d=$(echo "$*" | sed s/-I/-D/g)
    [ "$d" != "$*" ] && ip6tables $d >/dev/null 2>&1
		d=$(echo "$*" | sed s/-N/-F/g)
    [ "$d" != "$*" ] && ip6tables $d >/dev/null 2>&1
		d=$(echo "$*" | sed s/-N/-X/g)
    [ "$d" != "$*" ] && ip6tables $d >/dev/null 2>&1
		d="$*"
		ip6tables $d >/dev/null 2>&1 || output "\n$_error_: ip6tables $d\n"
}

table_destroy(){
	local tid="$1" tunnel="$2" ip_family="$3" ipset
	if [ "$ip_family" == "ipv6" ]; then
		ip_family="-6"; ipset="${tunnel:+${tunnel}route6}";
	else
		ip_family="-4"; ipset="${tunnel:+${tunnel}route}";
	fi
	if [ -n "$tid" ] && [ -n "$ipset" ]; then
	 	ip "$ip_family" rule del table "$tid" >/dev/null 2>&1
		ip "$ip_family" route flush table "$tid"
		ipset -q flush "$ipset"; ipset -q destroy "$ipset";
		ip "$ip_family" route flush cache;
		return 0
	fi
	return 1
}

table_create(){
	local tid="$1" mark="$2" tunnel="$3" gw="$4" ip_family="$5" ipv6_prefix="$6" ipv6_dev="$7" dscp s=0 ipset_family ipset iplist param_ipset param_dscp command
	if [ "$ip_family" == "ipv6" ]; then
		ip_family="-6"; ipset_family="inet6"; ipset="${tunnel:+${tunnel}route6}"; command=ipt6;
	else
		ip_family="-4"; ipset_family="inet"; ipset="${tunnel:+${tunnel}route}"; command=ipt4;
	fi
	iplist="${tunnel:+${tunnel}list}"

	if [[ -n "$tid" && -n "$mark" && -n "$ipset" ]]; then
		table_destroy "$tid" "$tunnel" "$ip_family" || s=1
		param_ipset="-t mangle -A OPR_CHAIN -m set --match-set $ipset dst -j MARK --set-xmark ${mark}/${FW_MASK}"
		dscp=$(uci -q get openvpn-policy-routing.config.${tunnel}_dscp)
		[[ ${dscp:-0} -ge 1 ]] && [[ ${dscp:-0} -le 63 ]] && param_dscp="-t mangle -A OPR_CHAIN -m dscp --dscp ${dscp} -j MARK --set-xmark ${mark}/${FW_MASK}"

		if [ -z "$gw" ]; then
			[[ $strict -ne 0 ]] && { ip $ip_family route add unreachable default table $tid || s=1; }
		else
			if [ "$ip_family" = "-4" ]; then
				ip $ip_family route add default via $gw table $tid  >/dev/null 2>&1 || s=1
			elif [[ -n "$ipv6_prefix" && -n "$ipv6_dev" ]]; then
				ip $ip_family route add default from $ipv6_prefix via $gw dev $ipv6_dev table $tid  >/dev/null 2>&1 || s=1
			else
				s=1
			fi
		fi
		ip route flush cache || s=1
		ipset -q -exist create "$ipset" hash:ip family $ipset_family && ipset -q flush $ipset || s=1
		ipset -q -exist create "$iplist" list:set && ipset -q -exist add $iplist $ipset || s=1
		[ -n "$param_ipset" ] && $command $param_ipset || s=1
		[ -n "$param_dscp" ] && { $command $param_dscp || s=1; }
		ip $ip_family rule add fwmark $mark table $tid || s=1
	else
		s=1
	fi

	return $s
}

process_interface(){
	local rp gw4 gw6 dev s=0 dscp pref6 setup_ipv4 setup_ipv6 pref6
	case "$1" in
		"$wan_if4" | "$wan_if6" )	rp="$1";;
		* ) config_get rp $1 ifname;;
	esac

	[ -z "$rp" ] && return 0
	case "$rp" in
		"$wan_if4" )
					network_get_gateway gw4 $1; config_get dev "$1" ifname; rp='wan'; setup_ipv4=1;;
		"$wan_if6" )
					network_get_gateway6 gw6 $1; config_get dev "$1" ifname; rp='wan'; network_get_prefix6 pref6 $wan_if6; setup_ipv6=1;;
		tun* | tap* )
					gw4=$(ifconfig "$rp" 2>/dev/null | grep 'inet addr:' | grep 'P-t-P' | awk '{print $3}' | awk -F ":" '{print $2}');
					gw6=$(ifconfig "$rp" 2>/dev/null | grep 'inet6 addr:' | awk '{print $3}'); gw6=${gw6:+"${gw6%:*}:1"};
					dev="$rp"; setup_ipv4=1; network_get_prefix6 pref6 $wan_if6; setup_ipv6=1;
					;;
		* ) return 0;;
	esac
	[ $((MARK_VPN)) -gt $((FW_MASK)) ] && return 1
	if [ -n "$setup_ipv4" ]; then
		[ -z "$TID_VPN" ] && TID_VPN="$TID_WAN"; [ -z "$MARK_VPN" ] && MARK_VPN="$MARK_WAN";
		eval tid_$rp="$TID_VPN"; eval mark_$rp="$MARK_VPN"; eval if_$rp="$1"; eval gw_$rp="$gw4"
		if [ "$2" == "create" ]; then
			pad_output 2 "creating table $1/$dev/${gw4:-0.0.0.0}/${rp}route"
			table_create "$TID_VPN" "$MARK_VPN" "${rp}" "$gw4" "ipv4" && s_status="$s_status $1/${gw4:-0.0.0.0}" && ok || fail
		elif [ "$2" == "destroy" ]; then
			table_destroy "$TID_VPN" "${rp}" "ipv4"
		fi
		TID_VPN=$((TID_VPN + 1)); MARK_VPN=$(printf "0x%06x" $((MARK_VPN + MARK_WAN)));
	fi
	if [[ -n "$setup_ipv6" && -n "$gw6" && -n "$pref6" ]]; then
		eval tid6_$rp="$TID_VPN"; eval mark6_$rp="$MARK_VPN"; eval if6_$rp="$1"; eval gw6_$rp="$gw6"
		if [ "$2" == "create" ]; then
			pad_output 2 "creating table $1/$dev/${gw6:-::/0}/${rp}route6"
			table_create "$TID_VPN" "$MARK_VPN" "${rp}" "$gw6" "ipv6" "$pref6" "$dev" && s_status="$s_status $1/${gw6:-::/0}" && ok || fail
		elif [ "$2" == "destroy" ]; then
			table_destroy "$TID_VPN" "${rp}" "ipv6"
		fi
		TID_VPN=$((TID_VPN + 1)); MARK_VPN=$(printf "0x%06x" $((MARK_VPN + MARK_WAN)));
	fi

	return $s
}

process_policy(){
	local comment gw mark laddr lport raddr rport command param ip_family="$2"
	config_get comment "$1" comment
	config_get gw      "$1" gateway
	config_get laddr   "$1" local_addrs
	config_get lport   "$1" local_ports
	config_get raddr   "$1" remote_addrs
	config_get rport   "$1" remote_ports

	case $gw in
		wan | tun* | tap*)
			if [ "$ip_family" == "ipv6" ]; then
				mark=$(eval echo "\$mark6_$gw")
#				[ -n "$laddr" ] && laddr="[$laddr]"
#				[ -n "$raddr" ] && raddr="[$raddr]"
			else
				mark=$(eval echo "\$mark_$gw")
			fi
			[ -z "$mark" ] && { output "$_error_: $p_name unknown fw_mark for ${ip_family}/${gw}!\n"; return 1; }
			param="-t mangle -I OPR_CHAIN 1 -j MARK --set-xmark ${mark}/${FW_MASK}"
			;;
		*)
			output "$_error_: $p_name unknown policy gateway ($gw)!\n"; return 1;;
	esac
	[ -z "$laddr" ] && [ -z "$lport" ] && [ -z "$raddr" ] && [ -z "$rport" ] && output "$_error_: $p_name policy '$comment' missing all IPs/ports!\n" && return

	[ -n "$laddr" ] && param="$param -s $laddr"
	[ -n "$lport" ] && param="$param -p tcp -m multiport --sport ${lport//-/:}" && lport=":${lport}"
	[ -n "$raddr" ] && param="$param -d $raddr"
	[ -n "$rport" ] && param="$param -p tcp -m multiport --dport ${rport//-/:}" && rport=":${rport}"

	if [ "$ip_family" == "ipv6" ]; then
		command=ipt6
		[ -z "$laddr" ] && network_get_subnet6 laddr lan6
		[ -z "$raddr" ] && raddr='::/0'
	else
		command=ipt4
		[ -z "$laddr" ] && network_get_subnet laddr lan
		[ -z "$raddr" ] && raddr='*.*.*.*'
	fi

	pad_output 2 "routing ${comment:+'$comment' }${laddr}${lport} to ${raddr}${rport} via ${gw}"
	$command $param && ok || { fail; output "$_error_: $command ${param}\n"; }
}

start_service() {
	local d_status s_status counter
  is_enabled || return 1

	[ -z "$wan_gw" ] && output "$_error_: $p_name could not discover wan gateway!\n" && exit 1

	ipt -t mangle -D PREROUTING -m mark --mark 0x00/${FW_MASK} -g OPR_CHAIN
	ipt -t mangle -N OPR_CHAIN; ipt -t mangle -A PREROUTING -m mark --mark 0x00/${FW_MASK} -g OPR_CHAIN;
#	iptables -t mangle -I OPR_CHAIN 1 -m mark --mark 0x00/${FW_MASK} -j ACCEPT
	{ modprobe xt_set; modprobe ip_set; modprobe ip_set_hash_ip; } >/dev/null 2>&1;

	output 1 'processing gw-interfaces '
	config_load network; config_foreach process_interface interface create;
	output 1 '\n'
	output 1 'routing IP/IPv6 policies '
	config_load openvpn-policy-routing; config_foreach process_policy policy; config_foreach process_policy policy_ipv6 "ipv6";
	output 1 '\n'
	if f_ipset 'internal' 'ipset'; then
		output 3 'routing domains policies '
		f_ipset 'internal' 'process'
		[ -z "$d_status" ] || output "$_error_:$d_status\n"
	fi
	if f_ipset 'dnsmasq' 'ipset'; then
		output 3 'routing dnsmasq policies '
		if [ ! -x /usr/sbin/dnsmasq ] || /usr/sbin/dnsmasq --version | grep -q 'no-ipset'; then
			fail; output "$_error_: domain-based routing requires 'dnsmasq-full', please see $readmeURL#requirements for details.\n";
		elif [ ! -e /var/run/dnsmasq/dnsmasq.*.pid ]; then
			fail; output "$_error_: dnsmasq doesn't seem to be running.\n";
		elif ! f_ipset 'dnsmasq' 'active'; then
			fail; output "$_error_: dnsmasq doesn't seem to be used for name resolution.\n";
		else
			f_ipset 'dnsmasq' 'output'
		fi
	fi

	if [ -z "$s_status" ]; then
		output "$_error_: $p_name failed to find any gateway!\n"; return 1;
	else
		[[ $strict -ne 0 ]] && [ "${s_status/0.0.0.0}" != "${s_status}" ] && s_status=" (strict mode):${s_status}"
		output "$p_name started${s_status} $_ok_\n"
	fi
}

stop_service() {
  is_enabled || return 1
	config_load network; config_foreach process_interface interface destroy
	ipt -t mangle -D PREROUTING -m mark --mark 0x00/${FW_MASK} -g OPR_CHAIN
	ipt -t mangle -F OPR_CHAIN; ipt -t mangle -X OPR_CHAIN;
	unset TID_VPN; unset MARK_VPN;
	output "$p_name stopped $_ok_\n"
}

reload_service(){
	start_service
}

st_load_interface(){ local d; config_get d $1 ifname; [ "$1" == "$wan_if4" ] || [ "$1" == "$wan_if6" ] || [ "$d" != "${d/tun}" ] || [ "$d" != "${d/tap}" ] && ifaces=" ${1} ${ifaces}"; }
service_triggers() {
		local ifaces n
		config_load network; config_foreach st_load_interface interface;
		procd_add_reload_trigger 'openvpn-policy-routing'
		procd_open_trigger
		procd_add_config_trigger "config.change" "openvpn-policy-routing" /etc/init.d/openvpn-policy-routing reload
		for n in $ifaces; do procd_add_interface_trigger "interface.*" "$n" /etc/init.d/openvpn-policy-routing reload; done;
		procd_close_trigger
}
